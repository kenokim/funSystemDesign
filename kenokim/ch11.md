# ch11. 뉴스 피드 시스템
- Q). 읽기/쓰기 트래픽이 몰리는 경우를 대응하기 위해 최적화하는 방법? 단, DB와 쿼리는 수정 불가능하다고 하자.

---
## 읽기 최적화

## 1. 캐싱(Caching)
- **애플리케이션 레벨 캐싱**: 자주 조회되는 데이터를 메모리에 저장.
- **Redis/Memcached**: 분산 캐시 시스템으로 데이터베이스 부하 감소.
- **CDN**: 정적 리소스 캐싱으로 네트워크 부하 감소.

## 2. 데이터 복제 및 로드 밸런싱
- **Read Replica**: 읽기 전용 데이터 복제본에 읽기 요청 분산.
- **로드 밸런서**: 읽기 트래픽을 복제본으로 자동 분산.

## 3. 프록시 및 API 게이트웨이
- **프록시 서버(Nginx, Varnish)**: 캐싱 계층 추가.
- **API 게이트웨이**: 내장된 캐싱 기능 활용.

## 4. 데이터 집계 및 미리 계산
- **Pre-Computed Data**: 자주 조회되는 데이터를 미리 계산 후 캐시에 저장.
- **배치 처리**: 일정 주기로 데이터 미리 계산 및 저장.

## 5. 결과 크기 최적화
- **Pagination**: 한 번에 대량의 데이터를 조회하지 않고 필요한 만큼만 조회.

## 6. 비동기 데이터 처리
- **비동기 요청**: 응답 속도 최소화.
- **백그라운드 데이터 로드**: 미리 데이터를 로드하여 캐시에 저장.

## 7. 데이터 압축 및 전송 최적화
- **Gzip**: 응답 데이터 압축으로 전송량 감소.
- **최소 데이터 전송**: 필요한 데이터만 반환.

## 8. 이벤트 기반 읽기 모델
- **Event-Driven Architecture**: 쓰기 시 이벤트를 발생시켜 캐시나 읽기 모델 업데이트.

## 고려사항
- **데이터 손실 방지**: 메시지 큐나 캐시에 데이터가 유실되지 않도록 설정.
- **일관성 관리**: 비동기 쓰기 및 캐시 사용 시 데이터 일관성 유지 전략 필요.
- **장애 복구**: 이벤트 소싱, 로그 기반 복구 등을 통해 복구 메커니즘 설계.

---

## 쓰기 최적화

## 1. 비동기 쓰기(Write Buffering)
- **메시지 큐(Kafka, RabbitMQ)**: 쓰기 요청을 큐에 저장한 후 비동기로 DB에 저장.
- **장점**: DB 부하 감소, 트래픽 스파이크 처리 가능.

## 2. 쓰기 캐싱(Write Caching)
- **Write-Behind Cache**: 캐시에 먼저 저장한 뒤 일정 시간 후 DB에 반영.
- **Write-Through Cache**: 캐시와 DB에 동시에 쓰기.
- **장점**: 빠른 응답 속도.

## 3. 배치 처리(Batching)
- **여러 쓰기 요청을 묶어서 한 번에 처리**하여 I/O 오버헤드 감소.
- **예**: 로그 데이터, 주문 내역 등을 주기적으로 일괄 저장.

## 4. 트랜잭션 최소화
- 트랜잭션 범위를 줄여 **락 경쟁**을 줄이고 쓰기 성능을 향상.
- **예**: 가능한 단일 테이블에만 쓰기.

## 5. 파티셔닝(Sharding)
- 데이터를 **Shard(파티션)**로 나누어 여러 DB에 분산 저장.
- **장점**: 쓰기 부하 분산, 확장성 확보.

## 6. 데이터 압축 및 최소화
- **압축 데이터 저장**으로 저장 공간 절약 및 I/O 감소.
- **중복 데이터 제거**로 쓰기 크기 최소화.

## 7. 이벤트 소싱(Event Sourcing)
- 상태를 저장하지 않고 **이벤트**를 기록하여 상태를 재구성.
- **장점**: 쓰기 작업 단순화, 데이터 복구 용이.

## 8. 쓰기 전용 아키텍처
- **쓰기 전용 데이터베이스**를 따로 구성하여 쓰기 부하 분산.
- 읽기 요청은 별도의 읽기 전용 데이터베이스에서 처리.

---



## 고려사항
- **데이터 일관성**: 캐싱 및 복제본 활용 시 동기화 전략 필요.
- **실시간성**: 캐싱이 실시간 요구사항에 부적합할 수 있음.
- **트래픽 분석**: 데이터 요청 패턴 분석 후 최적화 적용.

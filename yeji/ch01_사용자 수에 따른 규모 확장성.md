### [단일서버]

- 웹/앱/데이터베이스/캐시 등이 한대의 서버에 존재
- DNS 는 서드파티(제3사업자)가 제공하는 유료 서비스 이용, 도메인 이름을 ip주소로 변환하여 줌
- 웹 어플리케이션
    - 비즈니스 로직 , 데이터 저장 → 서버언어(java, python)
    - 프리젠테이션 → 클라이언트 언어(html? javascript)
- 모바일 어플리케이션 ↔ 웹서버
    - http 프로토콜 & json응답

### [데이터베이스]

- 사용자가 늘면 서버하나로는 충분하지 않아서  웹/모바일 트래픽 처리용 & 데이터베이스용 서버로 나눔
- RDBMS - mysql oracle postgreSQL
- NoSql - CouchDB Neo4j Cassandra DynamoDB
    - 낮은 응답지연시간(latency) , 비정형 데이터 , 직-역직렬화 , 많은양의 데이터

### [수직적 규모 확장 vs 수평적 규모 확장]

- 수직 (scale up) - 서버에 고사양 자원(cpu,ram등) 을 추가
    - 장애에 대한 자동 복구나 다중화 방안 제시 X, 장애시 서비스 완전 중단
- 수평 (scale out) -  더 많은 서버 추가

### [로드밸런서] ← 웹 계층

- 웹서버에 바로 연결되면 장애 시 서비스 접근X, 많은 사용자 발생 시 속도 저하/ 접근불가
    - 부하 분산기 or 로드밸런서 도입으로 해결
- 트래픽 부하를 고르게 분산하는 역할
- 프로세스
    - 사용자는 로드밸런서의 공개 ip로 접속
    - 웹서버는 클라이언트의 접속을 직접 처리하지 않고, 보안을 위해 서버간 통신에는 사설ip 주소 이용 ( 같은 네트워크에 속한 서버 사이의 통신에서만 쓰이는 주소)
- 장애 자동복구, 가용성 향상 (웹 계층)
    - 서버한대가 다운되면 다른 서버로 트래픽이 전송됨.
    - 기존의 서버개수로도 감당이 안되는 시점에 서버를 추가하기만 하면 로드밸런서가 자동으로 트래픽 분산

### [데이터베이스 다중화] ← 데이터베이스 계층

- 마스터-슬레이브
    - 원본은 마스터, 사본을 슬레이브에 저장하는방식
    - write는 마스터, read는 슬레이브에서 지원
    - 통상적으로 쓰기보다는 읽기 연산이 많음
    - 슬레이브 서버가 다운 → 마스터가 대체하거나 다른 슬레이브서버로 읽기 연산 분산
    - 마스터 서버 다운 → 슬레이브 서버가 마스터 서버가되고 슬레이브 서버를 추가, 복구 스크립트를 통해 없는 데이터를 추가. (다중 마스터나 원형 다중화 고려 [4,5])
- 성능, 안정성, 가용성 측면에서 이득
    - 성능 - 읽기 연산은 슬레이브에 분산될 수 있기때문에 쿼리 병렬처리 가능
    - 안정성 - 데이터베이스 서버 일부가 망가져도 데이터 보존 가능(분리된 지역에 다중화)
    - 가용성 - 여러 지역에 데이터를 복사해 두어 하나의 서버에 장애가 나도 다른서버를 사용하여 서비스 제공

### [캐시] ← 응답 시간

- 캐시를 붙이고 정적 콘텐츠를 cdn(content delivery network)로 옮겨서 응답시간 개선
- 자주 참조되는데이터, 값비싼 연산 결과를 메모리 안에 두고 다음 요청에 빠르게 처리되게 하는 저장소( 데이터베이스 호출이 성능에 많은 영향)
- 캐시 계층
    - 데이터를 잠시 보관, 데이터베이스보다 빠름. 성능 개선 및 데이터베이스의 부하감소효과. 독립적인 확장 가능
    - 읽기 주도형 캐시 전략 ( read-through caching strategy)  : 캐시에 있다면 해당데이터 사용, 없다면 데이터베이스에서 읽어 캐시에 저장한 뒤 클라이언트에 반환
    - 데이터 종류, 크기, 엑세스 패턴에 맞는 전략 선택 [6] 캐시전략비교
- 고려 사항
    - 어떤 상황?  -데이터 갱신이 적고 참조가 자주 일어나는 경우
    - 어떤 데이터 ?- 휘발성 데이터임. 영속적으로 저장할 데이터는 persistent data store에 두어야함
    - 데이터 만료 정책 - 너무 길면 원본과 차이, 짧으면 데이터베이스를 자주읽음
    - 일관성 - 원본 갱신과 캐시 갱신이 단일 트랜잭션으로 처리되지 않는 경우 일관성이 깨짐 [7]
    - 장애 대처 - 캐시서버가 한대인 경우 단일 장애 지점이 됨 ( 특정 지점에서의 장애가 전체 시스템의 동작은 중지 시킴)
    - 캐시 메모리 크기 - 작으면 엑세스 패턴에 따라 너무 자주 캐시에서 밀려나서eviction 성능 저하 ← 과할당으로 해결
    - 데이터 방출 정책(eviction) - 캐시가 꽉 찼을때 기존 데이터 중 어떤것을 내보낼지. 주로 LRU(lesat recently used)/LFU(least frequently used)/FIFO(first in first out)가 주로 사용됨

### [CDN] ← 응답 시간

- 정적 콘텐츠를 전송하는데 쓰이는 지리적으로 분산된 서버의 네트워크 . 이미지,비디오,css,javascript파일 등을 캐싱함
    - 동적 콘텐츠 캐싱은 request path, query string, cookie, request header 등의 정보에 기반하여 html 페이지를 캐싱 [9]
    - 정적 콘텐츠를 웹서버가 아닌 cdn에서 서비스하며 더 나은 성능을 보장
    - 캐시가 데이터베이스의 부하를 줄여줌
- 사용자에 가장 가까운 cdn 서버가 정적 콘텐츠를 전달 (TTL존재)
    - cdn 서버(웹서버 , 서드파티 온라인저장소..)의 캐시에 없는경우 원본 서버에 요청하여 파일을 가져옴
- 고려 사항
    - 비용 - CDN은 보통 서드파티(cloudfront, akamai..)에 의해 운영되고, 데이터전송 양에 따라요금책정. 자주 사용되지 않는 콘텐츠는 제거
    - 만료시점 - 길면 신선도 저하, 짧으면 빈번한 접속
    - 장애 대처 - 응답하지 않을 시 원본 서버에서 직접 가져오기 등
    - 콘텐츠 무효화 방법 - 만료되지 않은 콘텐츠여도
        
        서비스 api 사용/ 오브젝트 버저닝(image.png?v=2) 등의 방법을 통해 cdn에서 제거
        

### [무상태 웹 계층]← 수평적 확장

- 수평적 확장을 위해서는 상태정보( 사용자 세션 등)를 웹 계층에서 제거해야함.
- 상태 정보를 RDB나 NoSQL과같은 지속성 저장소에 보관하고 필요할때 가져옴
- 클라이언트정보 (=상태)를 유지하여 요청사이에 공유되도록 함
    - 상태의존적인 경우에는 항상 같은 서버로 요청이 전송되어야해서 로드밸런서가 제공하는 고정세션이라는 기능을 사용해야하고, 이는 로드밸런서에 부담을 주고 서버 추가 및 제거,장애 처리가 어려워짐
- 단순하고 안정적이며 규모확장이 쉽다
    - 자동규모 확장 - 트래픽 양에 따라 웹서버를 자동으로 추가하거나 삭제, 상태 정보가 웹서버로부터 제거되어서 가능해짐

### [데이터센터] ← 가용성, 전세계

다중 데이터 센터 아키텍처

- 트래픽 우회 - 올바른 데이터 센터로 트래픽을 보내는 방법을 찾아야함
    - 지리적 라우팅 (geoDns routing): 장애가 없는 상태에서 가장 가까운 데이터 센터로 안내 됨
        - 사용자의 위치에 따라 도메인 이름을 어떤 ip 주소로 변환할지 결정할 수 있도록 하는 dns 서비스
        - 장애 발생 시 장애가 없는 데이터 센터로 전송
- 데이터 동기화 - 장애가 자동복구(failover) 되어 트래픽이 다른 데이터베이스로 우회되어도 데이터가 없을 수 있음. 보편적으로 데이터를 여러 데이터 센터에 다중화 하는것으로 해결 [11]
- 테스트&배포 - 여러 위치에서 테스트, 자동화된 배포 도구는 모든 데이터센터에 동일한 서비스가 설치되도록 하는데 중요한 역할

### [메세지 큐] ← 독립적 확장

- 시스템을 확장하기 위해서는 시스템의 컴포넌트를 분리하여 각기 독립적으로 확장될 수 있어야함. 많은 분산 시스템이 메세지 큐를 전략으로 선택
- 메세지의 무손실을 보장하는 비동기 통신을 지원하는 컴포넌트
    - 메세지의 버퍼 , 비동기
    - 메세지를 만들어 메세지 큐에 발행하면 컨슈머가 메세지를 받아 맞는 동작 수행
    - 서비스간 결합이 느슨해져서 확장성이 보장되어야하는 안정적 어플리케이션 구상 가능
    - 오래 걸리는 작업을 비동기적으로 꺼내어 완료. 생산자와 소비자 서비스를 독립적으로 확장 할 수 있다.

### [로그, 메트릭, 자동화]

- 로그 : 에러 로그 모니터링, 로그를 단일서비스로 모아주는 도구 활용
- 메트릭
    - 호스트 단위 메트릭 - cpu , 메모리 등
    - 종합 메트릭 - 데이터베이스 계층 성능, 캐시 계층 성능
    - 핵심 비즈니스 메트릭 - dau, 수익, 재방문
- 자동화 : 생상성을 높이기 위한 자동화 도구들. 테스트빌드배포등의 절차도 자동화 가능

### [데이터베이스의 규모 확장

- 저장할 데이터가 많아지면 부하 증가, 수평/수직 규모 확장법
- 수직적 확장(scale up) - 더 많은 고성능 자원 증성
    - 무한히 증가할 수 없음, SPOF(single point of failure) 위험, 비용 증가
- 수평적 확장 (sharding)  - 더많은 서버를 추가하여 성능 확장, 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술. 모든 샤드는 같은 스키마르를 쓰지만 샤드간 데이터사이에는 중복이 없다
    - 샤딩 키 = 파티션 키를 정하는것이 가장 중요. 고르게 분할 될 수 있어야 한다.
    - 데이터 재 샤딩 - 데이터가 많아져서 증설, 데이터 분포가 고르지 못할때(샤드소진) → 샤드 키를 계산하는 함수를 변경하고 데이터를 재 배치해야한다 ( 안정해시 기법으로 해결 가능)
    - 유명인사(핫스팟) 키 문제 - 특정 샤드에 질의가 집중되어 과부하.
    - 조인과 비정규화 - 여러 샤드에 걸친 데이터 조인이 어렵기때문에 비정규화하여 하나의 테이블에서 질의가 수행되도록 함

[ 요약]

- 웹 계층은 무상태 계층으로 (상태정보 제거)
- 모든 계층에 다중화 도입 (마스터-슬레이브,)
- 가능한 한 많은 데이터를 캐싱 (메모리크기,데이터선정,방출정책)
- 여러 데이터 센터를 지원할 것 (라우팅기법, 데이터동기화)
- 정적콘텐츠는 cdn을 통해 서비스
- 데이터계층은 샤딩을 통해 규모 확장 ( 파티션키에 유의)
- 각 계층은 독립적 서비스로 분할 할 것 (큐를 이용해 가능)
- 시스템을 지속적으로 모니터링하고 자동화 도구를 활용

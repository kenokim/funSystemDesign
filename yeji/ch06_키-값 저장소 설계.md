- 비관계형 테이터베이스
    - 고유식별자를 키로 가지고 , 키-값 쌍형태로 저장되며 키를통해서만 값에 접근 가능
    - 키는 짧을수록 성능이 좋음
    - 값은 문자열,리스트,객체 전부 가능

- 설계 범위
    - 높은가용성, 트래필양에 따라 자동으로 추가삭제되는규모확장성,데이터일관성
- 단일 서버
    - 빠르지만 모든테이블을 메모리 안에 두는것이 불가능
    - 데이터 압축, 자주 쓰는것만 메모리에
- 분산 키-값 저장소 ( 분산 해시 테이블)
    - CAP 정리
        - consistency 일관성 - 어느노드에 접속하던 같은 데이터
            - cp시스템 - 쓰기 연산 중단 ( 은행권)
        - availability 가용성- 일부노드에 장애가 발생해도 같은 응답
            - AP 시스템 - 읽기 연산,쓰기 연산 허용하여 해결 뒤 장애노드에 데이터 전송
        - partittion tolerance 파티션 감내 - 두 노드사이에 장애가 발생(네트워크에 파티션)해도 계속 동작
        - 두가지를 충족하려면 하나는 희생되어야 함 , 네트워크 장애는 피할 수 없음으로 반드시 파티션 문제는 감내해야함 (ca 시스템은 존재 X)
    - 데이터 파티션
        - 데이터는 작은 파티션 단위로 나눠 여러대의 서버에 저장
        - 여러 서버에 고르게 분산할수 있는가 / 추가,삭제 시 데이터의 이동을 최소화할 수 있는가
            
            → 안정 해시를 사용 (규모확장 자동화& 다양성(각 서버의 용량에 맞게 가상노드 수 조정) 가능) 
            
    - 데이터 다중화
        - n개의 서버에 비동기적으로 데이터를 다중화하여 높은 가용성과 안정성 제공
        - 안정해시 에서 순회하며 만나는 첫n 개 서버에 데이터 사본 보관. 실제 물리서버갯수보다 n 이 작을경우 같은 물리서버를 중복 선택하지 않도록 해야함.
    - 데이터 일관성
        - 정족수 합의 프로토콜로 읽기쓰기에 일관성 보장
        - n 사본갯수 , w 쓰기연산에 대한 정족수 ( w개의 응답을 받아야 성공) R 읽기연산 정족수(R개 응답..)
        - 중재자가 클라이언트와 노드사이에서 프록시 열할을 함
            - R = 1 W = Nz 빠른 읽기 연산에 최적화된 시스템
            - W = 1 R=N: 빠른 쓰기 연산에 최적화된 시스템
            - W + R >N: 강한 일관성이 보장될 (보통 N = 3 W = R = 2 )
            - W + R <= N: 강한 일관성이 보장되지 않음
    - 일관성 모델
        - 강한 일관성 - 무조건 가장 최신
            - 모든 사본에 쓰기결과가 반영될떄까지 읽기/쓰기 금지 ( 가용성 보장X)
        - 약한 일관성- 가장 최신이 아닐 수 있음
        - 최종 일관성- 약한일관성의 종류, 갱신결과가 모든 사본에 반영(동기화)
            - 병렬적으로 방생 할 경우 일관성이 꺠질 수 있어서 클라이언트가 해결. 데이터의 버전 정보를 활용해 일관성이 꺠진 데이터를 읽지 않도록 함
        - 비 일관성 해소 기법 : 데이터 버저닝, 벡터 시계
            - 데이터를 변경할떄마다 해당 데이터의 새로운 버전을 만듬
            - 벡터 시계는 [서버,버전]의 순서쌍을 데이터에 메담. 버전충돌을 판별할때 사용
            - 충돌 감지 및 해소로직이 클라이언트에 들어가야해서 복잡,
            - 순서쌍 개수가 굉장히 빨리 늘어나서 길이에 임계치를 설정하고 오래된 순서쌍을 제거하도록해야함. 대신 버전간 선후 관계가 정확하게 결정될 수 없음
    - 장애 처리
        - 장애감지
            - 모든 노드에사이에 멀티캐스팅 채널 구축
            - 분산형 장애 감지 솔루션 :가십 프로토콜
                - 각 노드는 멤버쉽 목록을 유지( 멤버id, 하트비트 카운터)
                - 각노드는 주기적으로 자신의 하트비트 카운터를 증가
                - 각 노드는 무작위로 선정된 노드들에게 주기적으로 목록을 보냄
                - 받은 노드는 최신값으로 갱신. 어떤 노드의 값이 지정된 시간동안 갱신되지 않으면 해당멤버를 장애상태인것으로 간주
        - 장애 해소
            - 일시적 장애처리
                - 엄격한 정족수 - 읽기 쓰기 연산 금지
                - 느슨한 정족수 - 정족수 요구사항을 강제하는 대신 읽기쓰기를 건강한 서버만 해시링에서 고름
                    - 단서 후 임시 위탁 기법 hinted handoff -  쓰기연산을 처리한 서버가 힌트를 남겨 장애 해결 시 변경사항 일괄 반영
            - 영구 장애 처리
                - 반 엔트로피 프로토콜 - 사본들을 비교하여 항상 최신 버전으로 갱신, 일관성이 망가진 상태르 ㄹ탐지하고 전송데이터의 양을 줄이기 위해 머클 트리 사용
                - 머클트리 (해시트리) - 각노드에 자식노드들에 보관된 값의 해시, 레이블로부터 계산된 해시값을 레입ㄹ로 붙여두는 트리. 대규모 자료구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증 가능
                    - 버킷 단위로 나누고 해시르 ㄹ할당. 해시를 비교해서 같으면 두 서버는 같은 데이터를 가짐. 왼쪽이 일치하며 ㄴ오른쪽 탐색하느 ㄴ방식으로.  그 버킷만 동기화하면되고 총량과는 무관해짐 . 하지만 보통 버킷하나의 크기가 꽤 크다.
            - 데이터 센터 장애 처리
                - 자연재해 네트워크 장애 등
    - 시스템 아키텍처 다이어그램
        - 클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, 즉 get(key) 및 put(key, value)와 통신한다.
        - 중재자(coordinator)는 클라이언트에게 키-값 저장소에 대한 프락시(proxy) 역할을 하는 노드다.
        - 노드는 안정 해시(consistent hash)의 해시 링(hash ring) 위에 분포한다.
        - 노드를 자동으로 추가 또는 삭제할 수 있도록, 시스템은 완전히 분산된다 (decentralized),
        - 데이터는 여러 노드에 다중화된다.
        - 모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않는다.
        -
        
    - 쓰기경로
        - 쓰기요청이 커밋로그 파일에 기록 → 데이터가 메모리 캐시에 기록 → 가득 차거나 임계치에 도달하면 데이터는 디스크에 있는 SSTABLE에 기록됨 (sorted stirng table, 키값수너쌍을 정렬된 리스트형태로 관리하는 테이블)
            
           -
    - 읽기 경로
        - 메모리에 캐시가 있는경우 데이터를 클라이언트에 반환
        - 메모리가 캐시에 없는경우  디스크에서 가져옴. 어느 sstable에 있는지 알아내는 방법으로 블룸 필터 사용
           -

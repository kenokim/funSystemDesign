

# 사용자 수에 따른 규모 확장성


## 단일 서버

![[./images/Pasted image 20241029232056.png]]
1. DNS 서버에 도메인을 질의하여 IP주소로 변환
	- DNS는 보통 제3 사업자가 제공하는 서비스를 이용하게 됨
2. DNS 질의 결과로 서버의 IP 주소가 반환됨
3. 반환된 IP 주소로 HTTP (HyperText Transfer Protocl) 요청을 전달
4. 요청을 받은 웹 서버가 HTML, JSON 형태의 응답을 반환함




## 데이터베이스

![[./images/Pasted image 20241029232330.png]]
사용자가 늘어나면 서버를 한 대 이상 두어야 함.
- 웹/모바일 트래픽 처리 용도 서버
- 데이터베이스용 서버
이렇게 웹 계층과 데이터 계층을 분리하면 각각을 독립적으로 확장해 나갈 수 있음
### 어떤 데이터베이스를 사용할 것인가?
전통적인 관계형 DB와 비-관계형 DB로 나뉨

#### 관계형 DB (Relational Data-base Management System, RDBMS)
- Mysql, Oracle Database, PostgreSQL 등이 있음
- 자료를 열, 컬럼으로 표현함
- SQL을 사용하면 여러 테이블에 있는 데이터를 그 관계에 따라 Join 하여 합칠 수 있음.

#### 비 관계형 데이터베이스 (NoSQL)
- CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB, MongoDB 등이 있음
- 네 부류로 나눌 수 있음
	- 키-값 저장소 (key-value store)
	- 그래프 저장소 (graph store)
	- 컬럼 저장소 (column store)
	- 문서 저장소 (document store)
- 비 관계형 데이터베이스는 일반적으로 join 연산은 지원하지 않음
- 다음과 같은 경우에 유용함
	- 아주 낮은 응답 지연시간 (latency)가 요구됨
	- 다루는 데이터가 비정형 (unstructured)이라 관계형 데이터가 아님
	- 데이터를 직렬화(serialize) 하거나 역직렬화(deserialize) 할 수 있기만 하면 됨
	- 아주 많은 양의 데이터를 저장할 필요가 있음
	- ==**WHY?**==
		- 유연한 스키마 구조, 변경 사항에 유연한 대응 가능
		- 빠른 읽기 쓰기 환경에 적합
		- 다양한 데이터 형식 지원
		- 고가용성 기능이 내장되어 있음

## 수직적 규모 확장 vs 수평적 규모 확장

- 스케일 업 (Scale up)
	- 수직적 규모 확장 (vertical scaling)
	- 서버에 고사양 자원(CPU, RAM 등)을 추가하여 성능을 개선하는 행위
	- 트래픽 양이 적은 경우에 적합
	- 장점
		- 단순하게 실현 가능함
	- 단점
		- 확장에는 ==한계가 있음==, 무한대로 CPU RAM을 증설할 수 없음
		- 장애에 대한 대처 방안이 없음
			- 자동 복구 (failover) or 다중화 (redundancy) 방안이 없음
			- 장애 발생 시 서비스 완전 중단됨
			- ==진짜 없나?==
				- RAID, 데이터 중복성 확보
				- 데이터베이스 복제 (Replication)
				- UPS 사용
				- 애플리케이션 레벨의 health check 운영과 자동화된 장애 조치, Nginx HaProxy의 기능 사용
- 스케일 아웃 (Scale out)
	- 수평적 규모 확장 (horizontal scaling)
	- 더 많은 서버를 추가하여 성능을 개선하는 행위
	- 대규모 어플리케이션인 경우에 적합

앞선 설계에서 사용자는 웹 서버에 바로 접속됨
웹 서버가 다운되거나 트래픽이 많아져 웹 서버가 한계에 도달하면 응답 속도가 느려지거나 서버 접속이 불가능 해짐
=> 부하 분산기/로드밸런서 도입

### 로드밸런서
부하 분산 집합 (load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 함.

![[./images/Pasted image 20241029234641.png]]

- 사용자는 로드밸런서의 공개 IP 주소로 접속함
- 웹 서버는 클라이언트의 접속을 직접 처리하지 않음
- 보안을 위해 서버간 통신에는 사설 IP 주소가 사용됨
	- 사설 IP는 같은 네트워크에 속한 서버 사이의 통신에서만 쓸 수 있는 IP 주소, 인터넷으로 접속 불가
- 부하 분산 집합에 웹 서버를 추가하면
  장애 자동복구 불가능 문제(no failover) 문제는 해소되며, 가용성 (availability)이 향상됨
	- 서버1이 다운되면 모든 트래픽을 서버2로 전송
		- 서비스 전체가 다운되는 것을 방지할 수 있음 (failover)
	- 부하를 나누기 위해서 새로운 서버를 추가할 수 있음

### 데이터베이스 다중화

- 서버 사이에 master-slave 관계를 설정함
- 데이터 원본은 master 서버에, 사본은 slave 서버에 저장
- 쓰기 연산 (write operation)은 master에서만 지원
	- insert, delete, update
- slave는 읽기 연산(read operation)만 지원
- 대부분의 어플리케이션은 읽기 연산의 비중이 높음, 따라서 통상적으로 slave 서버가 master 서버보다 많음


![[./images/Pasted image 20241029235723.png]]
데이터베이스 다중화의 장점
- 더 나은 성능, 읽기 연산은 slave 서버들로 분산되어 처리되기 때문에 병렬로 처리될 수 있는 질의(query) 수가 늘어남
- 안정성(reliability), 지역적으로 떨어진 여러 장소에 다중화 시킬 수 있기 때문에 자연 재해 등으로 서버 손실이 일어나도 데이터는 보존할 수 있음
- 가용성(availability), 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 서비스 지속 가능

데이터베이스 서버가 다운되면 생기는 일
- slave 서버의 다운
	- slave 서버가 1대인 경우, 일시적으로 모든 읽기 연산이 주 데이터베이스로 전송됨.
	- slave 서버가 여러대인 경우, 읽기 연산은 다른 slave 서버로 분산됨
- master 서버의 다운
	- slave 서버가 1대인 경우, 해당 slave 서버가 새로운 master 서버가 됨
	- slave 서버에 저장된 데이터가 최신 상태가 아닐 수 있음
		- 복구 스크립트 (recovery script)를 실행하여 없는 데이터를 추가해야 함
		- 다중 마스터 (multi-masters)나 원형 다중화(circular replica-tion) 방식으로 대처 가능
			- ==참고 문헌==


### 로드밸런서와 데이터베이스 다중화를 고려한 설계

![[./images/Pasted image 20241030000606.png]]

- 사용자는 DNS에서 로드밸런서의 Public IP를 받고, 해당 IP에 접속
- 로드밸런서는 요청을 서버1/서버2로 전달
- 웹 서버는 데이터를 slave 데이터베이스에서 읽어옴
- 데이터 변경 연산은 master 데이터베이스로 전달됨
	- 데이터 추가, 삭제, 갱신 연산이 해당

## 캐시
> 비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고
> 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소

### 캐시 계층
- 데이터가 잠시 보관되는 곳
- 데이터베이스보다 훨씬 빠름
- 별도의 캐시 계층을 두면 성능 개선 및 DB 부하 감소 가능
- 캐시 계층의 규모를 독립적으로 확장시킬 수 있음

![[./images/Pasted image 20241030001528.png]]
**읽기 주도형 캐시 전략 (read-through caching strategy)**
1. 요청을 받은 웹 서버는 캐시에 응답이 저장되어 있는지 확인
2. 저장되어 있다면 해당 데이터를 반환
3. 없는 경우에는 DB 질의를 통해 얻은 데이터를 캐시에 저장한 뒤 반환

캐시 전략을 선택하는 기준
- 데이터의 종류
- 데이터의 크기
- 액세스 패턴
- ==참고 문헌==

### 캐시 사용시 고려사항
- 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어나는 경우
- 영속적으로 보관할 데이터는 저장하지 않는다
	- 캐시 서버가 재시작되는 경우 데이터는 사라진다
	- 중요 데이터는 지속적 저장소 (persistent data store)에 두어야 한다
- 캐시에 보관된 데이터의 만료 (expire)정책 수립
	- 만료 정책이 없으면 데이터가 계속 캐시에 남아있게 됨
	- 만료 기한이 너무 짧으면 DB 읽기가 많아짐
	- 만료 기한이 너무 길면 원본 데이터와 차이가 날 가능성이 높아짐
- 일관성 (consistency)유지, 데이터 저장소의 원본과 캐시 내의 사본이 같도록 유지시켜야 함
	- 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되어야 함
	- 여러 지역에 걸쳐 시스템을 확장하는 경우 캐시-저장소 사이의 일관성을 유지하는 것은 어려운 문제
		- ==참고 문헌==
- 캐시 서버를 분산시켜 단일 장애 지점 (Single Point of Failure, SPOF)을 피해야 함
	- SPOF: 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜 버릴 수 있는 경우, 해당 지점을 뜻함
	- 여러 지역에 걸쳐 캐시 서버를 분산시켜야 함
- 캐시 메모리의 크기를 적절히 지정해야 함
	- 너무 작으면 데이터가 너무 자주 축출(eviction)되어 캐시의 성능 저하가 일어남
	- eviction을 막기 위해서는 캐시 메모리를 과할당(overprovision)하면 해결됨
		- ==다른 방법은?==
			- 데이터 eviction 정책을 통해 최적화된 데이터 캐싱 전략을 사용하면 됨.
- 데이터 eviction 정책
	- 캐시가 꽉 차버리는 경우 기존 데이터를 소멸시켜야 함
	- 가장 보편적으로 LRU (Least Recently Used), 마지막으로 사용된 시점이 가장 오래된 데이터를 소멸하는 정책을 사용
	- LFU (Least Frequently Used), 사용된 빈도가 가장 낮은 데이터를 소멸하는 정책
	- FIFO (First In First Out), 가정 먼저 캐시에 들어온 데이터를 가장 먼서 소멸하는 정책

### 콘텐츠 전송 네트워크 (Content Delivery Network, CDN)
- CDN은 정적 콘텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크이다.
- 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있음

+동적 콘텐츠 캐싱도 존재함
- request path, query string, cookie, request header 에 기반한 HTML 페이지 캐싱 기법


![[./images/Pasted image 20241030003227.png]]
**CDN이 사이트 로딩 시간을 개선하는 방법**


![[./images/Pasted image 20241030003310.png]]
**CDN이 동작하는 과정**
1. 사용자A 가 image.png에 접근
	- URL의 도메인은 CDN 사업자가 제공한 주소
2. CDN 서버의 캐시에 이미지가 없는 경우, 원본 서버에서 파일을 가져옴
	- 원본 서버는 웹 서버일 수 있고, S3같은 온라인 저장소일 수 있음
3. 원본 서버가 CDN 서버에 데이터를 반환, 응답의 HTTP 헤더에는 해당 파일이 얼마나 오래 캐시될 수 있는지 TTL (Time-To-Live) 값으로 표시함
4. CDN 서버는 파일을 캐시하고 사용자 A에게 반환, TTL에 명시된 만큼 캐싱됨
5. 사용자B 가 동일한 이미지를 CDN 서버에 요청
6. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리

### CDN 사용시 고려사항
- 비용, CDN은 보통 제3 사업자 (third-party providers)에 의해 운영되며 CDN에 들어가고 나가는 데이터 전송 양에 따라 요금을 부과하게 됨
	- 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않음
- 적절한 만료 기한 설정, 시의성이 중요한 (time-sensitive) 콘텐츠의 경우 만료 시점을 적절히 정해야 함
- CDN 장애에 대한 대처 방안, CDN이 일시적으로 응답하지 않는 경우 원본 서버에서 직접 콘텐츠를 가져올 수 있도록 구성하는 것이 필요
- 콘텐츠 무효화 (invalidation) 방법, 아직 만료되지 않은 콘텐츠를 CDN에서 제거
	- CDN에서 제공하는 API를 사용하여 콘텐츠 무효화
	- object versioning을 이용하여 콘텐츠 무효화, ex) image.png?v=2

![[./images/Pasted image 20241030004038.png]]
**CDN과 캐시가 추가된 설계**
1. 정적 콘텐츠 (JS, CSS, Image 등)는 CDN을 통해 제공하여 더 나은 성능을 보장
2. 캐시가 DB의 부하를 감소시켜 줌


## 무상태(Stateless) 웹 계층

- 웹 계층을 수평적으로 확장하는 방법
- 사용자 상태 정보 (세션 데이터)를 웹 계층에서 제거해야 함
	- persist store에 저장하고 필요할 때 가져올 수 있도록 하는것이 좋음


![[./images/Pasted image 20241030004517.png]]
**상태 정보 의존적인 아키텍처**
- 사용자A 의 인증 요청은 항상 서버1 에서 처리되어야 함
- 로드밸런서의 고정 세션 (sticky session) 기능을 사용하여 해결할 수 있음
	- LB에 부담을 줌
	- 서버의 추가/제거가 까다로워짐
	- 장애 처리도 복잡해짐

![[./images/Pasted image 20241030004650.png]]
**stateless 아키텍처**
- 사용자의 요청은 어떤 웹 서버로든 전달 가능
- 상태 정보가 필요한 경우 웹 서버는 공유 저장소 (shared storage)에서 데이터를 가져옴
- 단순하고 안정적이며 규모 확장이 쉬움

![[./images/Pasted image 20241030004824.png]]
**stateless 웹 계층을 적용한 기존 설계**
- 세션 데이터를 웹 계층에서 분리하여 shared storage에 저장
	- RDBMS, Memcahed/Redis 캐시 시스템, NoSQL 이 사용 가능
- 1번의 자동 규모 확장(autoscaling)은 트래픽 양에 따라 웹 서버를 자동으로 추가/제거하는 기능


## 데이터 센터

![[./images/Pasted image 20241030005046.png]]
**2개의 데이터 센터를 이용하는 사례**
- 장애가 없는 상황에서는 가장 가까운 데이터 센터를 사용, 지리적 라우팅(geoDNS-routing or geo-routing)
- 지리적 라우팅에서의 geoDNS는 사용자의 위치에 따라 도메인을 어떤 IP 주소로 변환할지 결정할 수 있도록 하는 DNS 서비스
- x%의 사용자는 US-East 센터로, (100-x)%의 사용자는 US-West 센터로 이동함

![[./images/Pasted image 20241030005321.png]]
**데이터 센터중 하나에 장애가 발생한 경우**
- 모든 트래픽이 US-East로 전송됨

### 다중 데이터센터 아키텍처에서 해결해야 하는 문제들
- 트래픽 우회, 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 함
	- GeoDNS
- 데이터 동기화 (synchronization), 데이터 센터마다 별도의 DB를 사용하는 상황에는 failover가 일어나 트래픽이 우회되더라도 해당 데이터 센터에는 원하는 데이터가 없을 수 있음
	- 데이터를 여러 센터에 걸쳐 다중화 하는 것으로 해결 가능
	- ==Netflix가 다중화 하는 방법==
- 테스트와 배포 (deployment)
	- 서비스를 여러 위치에서 테스트해 보는 것이 중요함
	- 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 역할을 함

시스템을 더 큰 규모로 확장하기 위해서는 각 컴포넌트를 분리하여 독립적으로 확장될 수 있도록 해야 한다.
=> Message Queue

## 메세지 큐 (Message Queue)

> 메세지의 무손실 (durability),
> 메세지 큐에 보관된 메세지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성을 보장하는
> 비동기 통신(asynchronous communication)을 지원하는 컴포넌트

![[./images/Pasted image 20241030010006.png]]
**메세지 큐의 기본 아키텍처**
- 생산자 또는 발행자(producer/publisher)라고 불리는 입력 서비스가 메세지를 만들어
  메세지 큐에 발행(publish)
- 큐에 연결된 소비자 혹은 구독자(consumer/subscriber)라 불리는 서비스가 메세지를 받아 그에 맞는 동작을 수행함
- 서버 간 결합이 느슨해져서 규모 확장성이 보장되어야 하는 안적적인 서비스를 구성하기 좋음
	- consumer가 다운되어도 메세지를 publish 할 수 있음
	- producer가 다운되어 있어도 메세지를 수신할 수 있음


## 로그, 메트릭, 자동화

### 로그
- 시스템의 오류와 문제들을 쉽게 찾아낼 수 있도록 함
- 서버 단위의 모니터링도 있지만, 로그를 단일 서비스로 모아주는 도구를 활용하면 더 편리하게 조회 가능함

### 메트릭
- 사업 현황에 관한 유용한 정보를 얻을 수 있음
- 호스트 단위 메트릭: CPU, 메모리, 디스크 I/O
- 종합(aggregated) 메트릭: DB 계층의 성능, 캐시 계층의 성능
- 핵심 비즈니스 메트릭: DAU, 수익(revenue), 재방문(retention)

### 자동화
- 시스템이 크고 복잡해지면 생산성 향상을 위해 자동화 도구를 사용해야 함
- 지속적 통합 (continuous integration, CI), 개발자가 만드는 코드를 자동으로 검증하여 문제를 사전에 탐지


### 메세지 큐, 로그, 메트릭, 자동화 등을 반영한 설계안
![[./images/Pasted image 20241030015202.png]]
- 메세지 큐는 각 컴포넌트가 보다 느슨히 결합(loosely coupled)될 수 있도록 하고, 결함에 대한 내성을 높임
- 로그, 모니터링, 메트릭, 자동화 도구 추가


## 데이터베이스의 규모 확장

![[./images/Pasted image 20241030015853.png]]
**데이터베이스의 수직적 확장과 수평적 확장의 비교**
### 수직적 확장 (vertical scale up)
- 자원 늘리기 CPU RAM 디스크
- 무한 증설 불가능
- SPOF 위험성
- 비용 문제

### 수평적 확장 (horizontal scale up)
- DB의 수평적 확장은 샤딩(sharding)이라고 부름
	- 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술
	- 모든 샤드는 같은 스키마를 사용하지만, 샤드에 보관되는 데이터 사이에는 중복이 없음

![[./images/Pasted image 20241030015945.png]]
![[./images/Pasted image 20241030020028.png]]
**데이터를 샤드에 저장하는 예**
- user_id % 4의 연산 결과에 따라 어떤 shard에 저장할지 정하는 방식
- **각 샤드끼리 중복된 데이터는 존재하지 않음**

### Sharding에서 고려해야 할 사항
- 샤딩 키 (Sharding Key, Partition Key)를 어떻게 정할지
	- 데이터가 어떻게 분산될지 정하는 하나 이상의 컬럼으로 구성됨
	  (위 그림의 경우 sharding key는 user_id)
	- 샤딩 키는 데이터를 고르게 분할 시킬 수 있도록 하는 것이 가장 중요함
- 데이터의 재 샤딩 (resharding)
	- 데이터가 너무 많아져서 하나의 샤드로는 감당하기 어려울 때
	- 샤드 소진(shard exhaustion), 샤드 간 데이터 분포가 균등하지 못하여
	  한 샤드의 공간 소모가 빠른 경우
	- 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치 해야 함
	  => 안정 해기 (consistent hashing)기법으로 해결 가능
- 유명인사 (celebrity, hotspot key)문제
	- 특정 샤드에 질의가 집중되어 과부하가 걸리는 문제
	- 데이터를 더 잘개 쪼개야 할 수 있음
- 조인과 비정규화(join and de-normalization)
	- 하나의 DB를 여러 샤드로 쪼개면, 샤드에 걸친 데이터를 join하기 어려움
	- DB를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것으로 해결가능


![[./images/Pasted image 20241030020711.png]]
**DB Sharding을 적용한 설계도**

## 요약
- 웹 계층은 stateless 유지
- 모든 계층에 다중화 도입
- 가능한 많은 데이터를 캐싱
- 여러 데이터 센터를 유지
- 정적 콘텐츠는 CDN을 통해 서비스
- 데이터 계층은 샤딩을 통해 규모를 확장
- 각 계층은 독립적 서비스로 분할
- 시스템을 지속적으로 모니터링 하고, 자동화 도구를 사용

# 문제 이해 및 설계 범위 확정

- 키-값 쌍의 크기, 큰 데이터 저장 가능
- 고가용성
- 높은 규모 확장성
- 데이터 일관성 수준 조정 가능
- 짧은 응답 지연시간

### 단일 키-값 저장소는 어떨까?

메모리에 전부 **해시 테이블로 저장**하는 것은 가장 직관적이다. 

하지만 불가능하다.

따라서 아래 두 방법이 있다.

- 데이터 압축
- 자주 사용하면 캐시, 아니면 디스크 저장

이런 방법들이 있지만 여전히 한계가 존재한다.

# 분산 키-값 저장소

**분산 해시 테이블** 이라고도 불림.

### CAP 정리

- **Consistency**, 일관성: 어느 노드에 속해도 같은 데이터를 본다.
- **Availability**, 가용성: 장애가 발생해도 같은 응답을 받는다.
- **Partition Tolerance**, 파티션 감내: 두 노드 사이에 통신 장애가 발생(파티션 발생)에도 시스템은 계속 동작한다.

이 세가지를 전부 만족하는 분산 시스템 설계는 불가능

**보통 두 가지**를 시스템의 성격에 따라 고려

# 핵심 컴포넌트 및 기술

- 데이터 파티션
- 데이터 다중화
- 일관성
- 일관성 불일치 해소를 위한 모델
- 장애 처리
- 시스템 아키텐처 다이어그램
- 읽기 경로
- 쓰기 경로

## 데이터 파티션

### 파티셔닝과 샤딩

**분할 기법**이라고 하면 **파티셔닝과 샤딩이 존재**

**파티셔닝**

- 수직 분할(정규화와 유사, 정규화된 자주쓰는 데이터를 분할)
- 수평 분할(샤딩과 유사, 스키마를 복제해 파티셔닝 키를 기준으로 분할)

**수평 파티셔닝**과 **샤딩**의 차이점

- 수평 파티셔닝: 스키마를 복제해 파티셔닝 키를 기준으로 다른 테이블로 분할 → 하나의 서버
- 샤딩: 샤딩 키를 기준으로 서로 다른 DB 서버로 분할 → 여러 대의 서버

### 데이터를 파티션 단위 분할 시, 고려 사항

- 데이터를 여러 서버에 고르게 분산할 수 있나?
- 노드(서버) 추가/삭제 시에 데이터 이동을 최소화할 수 있나?

## 데이터 다중화(Replication)

고가용성과 안정성을 위해서는 (튜닝 가능한) N개의 서버에 **비동기 다중화**가 필요.

책에서는 간단하게 매커니즘을 소개한다.

### 다중화를 위한 서버 선택

1. N값을 지정
2. 해시 링 위에 데이터 배치
3. 시계 방향으로 순회하며 만나는 N개의 서버에 데이터 사본 보관

### 가상 노드를 사용시 주의점

실제 물리 서버의 개수가 N보다 작아질 수 있음.

따라서 노드를 선택할 때, 같은 물리 서버를 중복 선택하지 않도록 해야 한다.

## 데이터 일관성

여러 서버에 데이터가 존재할 때, **동기화**가 이루어져야 한다.

### 읽기/쓰기 연산에 일관성을 보장하고 싶다면?

정족수 합의(Quorum Consensus) 프로토콜을 사용

### 사전 정의

- N : 사본 개수
- W : 쓰기 연산에 대한 정족수
- R : 읽기 연산에 대한 정족수

즉, 해당 정족수가 충족이 되면(=성공 응답을 받았다면) 나머지 서버에 대한 응답을 기다리지 않아도 됨.

W=1 일 때, 중재자는 최소 1대의 서버에서 쓰기 성공 응답을 받으면 된다.

여기서 중재자는 클라이언트 - 노드 사이에 존재하는 프록시(proxy) 역할을 함.

### 그렇다면, N/W/R 값은 어떻게 지정?

이것이 응답 지연과 데이터 일관성 사이에서의 타협점을 찾는 일이 된다.

연산에 대한 정족수가 크다면 그만큼 응답 지연값이 커지지만 일관성을 그만큼 보장

몇 가지의 구성이 존재한다.

- R=1, W=N: 빠른 읽기 연산 최적화
- W=1, R=N: 빠른 쓰기 연산 최적화
- W+R > N: **강한 일관성** 보장 (보통 N=3, W=R=2)
- W+r <= N: 강한 일관성 보장 x

여기서 강한 일관성처럼 몇 가지 일관성 모델이 존재한다.

### 일관성 모델

- **강한 일관성**
    
    모든 읽기 연산은 가장 최근 갱신 결과를 반환. 클라이언트는 절대 낡은(out-of-date) 데이터 못 봄.
    
    결국 쓰기 연산이 완료될 때까지 읽기/쓰기 금지.
    
    고가용성에 부적합.
    
- **약한 일관성**
- **결과적 일관성**
    
    갱신 결과가 결국에는 모든 사본에 반영되는 모델. 즉 동기화가 됨.
    
    다이나모, 카산드라가 이 모델을 채택함.
    
    해당 모델은 쓰기 연산이 병렬적으로 진행되어 일관성이 깨질 수 있는데, 이를 **클라이언트가 해결**해야 한다.
    

### 데이터 버저닝과 벡터 시계

- 버저닝: 데이터 변경 시 새로운 버전을 만든다.
- 벡터 시계: 버저닝 과정에서 충돌을 발견하고 해결해내기 위한 시스템 기술로, [서버, 버전] 순서쌍을 데이터에 매단다.

### 벡터 시계

[서버, 버전] 순서쌍이 존재하므로, 충돌을 판별할 수 있다.

로직은 간단하다.

**[Si, vi]가 존재하면 증가, 그렇지 않으면 새 항목 생성 [Si, 1]**

자세한 과정은 생략.

여기서 충돌을 살피려면 버전 수를 확인하면 된다.

**Sy의 벡터 시계 구성요소가 Sx 보다 작은 값이 있다? 충돌이다.**

D([s0,1][s1,2]) D([s0,2][s1,1]) 둘은 서로 충돌한다. 후자는 s0의 버전 2인데, s1의 버전 1을 가지기 때문.

### 벡터 시계, 단점은?

1. 클라이언트 구현 복잡
2. [서버, 버전]의 순서쌍이 굉장히 빨리 늘어남.이때 임계치(threshold)를 설정하면 버전 간 선후 관계가 부정확해질 수 있다.

그치만 다이나모 DB에서는 충돌 해소 과정에서 이런 문제(임계치 설정으로 인한 효율성)가 벌어진 적은 없다고 함.

**대부분은 벡터 시계로 데이터 일관성을 지킬 수 있다!**

## 장애 처리

장애 처리는 두 가지 단계로 나뉜다.

- 장애 탐지(detection)
- 장애 해소(resolution)

### 가십 프로토콜

분산형 장애 감지 솔루션

동작원리는 다음과 같다.

- 각 노드는 멤버십 목록(멤버ID, 박동 카운터)을 유지함.
- 각 노드 주기적으로 박동 카운터 증가
- 노드는 무작위로 다른 선정된 노드에게 자신의 박동 카운터 목록을 전송
- 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신
    - 여기서 지정된 시간 동안 갱신이 안된 멤버가 있다면, 이는 장애(offline) 상태라고 간주한다.

*이를 처리하는 방법들은?*

### 일시적 장애 처리

### 엄격한 정족수

읽기/쓰기 연산을 금지한다. 일관성 유지를 위함.

### 느슨한 정족수

장애난 서버로 오는 요청은 다른 서버가 처리한다.

이 때 임시로 쓰기 연산을 처리하면 그에 대한 **힌트**를 남겨두는데, 이를 **임시 위탁** 기법이라고 한다.

### 영구 장애 처리

반-엔드로피 프로토콜을 구현해 사본을 동기화 한다.

사본들과 비교해 최신 버전으로 갱신하는 과정을 포함한다.

여기서 사본 간의 일관성이 망가진 **상태를 탐지**하고 **전송 데이터의 양의 감소**를 위해 머클 트리를 사용한다.

### 머클(Merkle) 트리(해시 트리)

각 노드에 다음과 같은 값을 레이블로 붙여두는 트리를 말한다.

- 그 자식 노드들에 보관된 값의 해시
- 또는 자식 노드들의 레이블로 계산된 해시

검증에 탁월함. 블록체인 개념에서 많이 쓰인다.

단계를 거치고 나면, 그림과 같이 상향식으로 이진 트리를 구성해 나가게 된다.

### 데이터 센터 장애 처리

- 다중화가 중요

## 시스템 아키텍처 다이어그램

이 아키텍처의 주 기능은 다음과 같다.

- 클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, 즉 get(key) 및 put(key, value)와 통신한다.
- 중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드이다.
- 노드는 안정 해시의 해시 링 위에 분포한다.

- 노드를 자동으로 추가/삭제할 수 있도록 시스템은 완전히 분산된다.
- 데이터는 여러 노드에 다중화된다.
- 모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않는다.

완전히 분산된 설계를 채택하였으므로, 모든 노드는 그림에서 제시된 기능 전부를 지원해야 한다.


### 쓰기 경로


쓰기 요청이 특정 노드에 전달되면 무슨 일이 벌어지는지를 보여준다.

1. 쓰기 요청이 커밋 로그 파일에 기록된다.
2. 데이터가 메모리 캐시에 기록된다.
3. 메모리 캐시가 가득차거나 사전에 정의된 어떤 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다. SSTable은 Sorted-String Table의 약어로, <키, 값>의 순서쌍을 정렬된 리스트 형태로 관리하는 테이블이다.

### 읽기 경로

읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 살핀다. 있는 경우는 아래와 같이 해당 데이터를 클라이언트에 반환한다.


데이터가 메모리에 없는 경우에는 디스크에서 가져와야 한다. 어느 SSTable에 찾는 키가 있는지 알아낼 효율적인 방법이 필요할 것이다.

이런 문제를 푸는데에는 블룸 필터가 흔히 사용된다.

데이터가 메모리에 없을 떄 읽기 연산이 처리되는 경로를 보면 그림과 같다.


1. 데이터가 메모리 있는지 검사한다. 없으면 2로
2. 데이터가 메모리에 없으므로 블룸 필터를 검사한다.
3. 블룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.
4. SSTable에서 데이터를 가져온다.
5. 해당 데이터를 클라이언트에 반환한다.

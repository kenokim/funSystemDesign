**처리율 제한 장치(rate limiter)** : 클라이언트 또는 서비스가 보내는 **트래픽의 처리율(rate)를 제어하기 위한 장치**이다.

API에 처리율 제한 장치를 두면 좋은 점

1. DOS(Denial of service) 공격에 의한 자원 고갈(resource startvation)을 방지할 수 있다.
2. 비용을 절감한다.
3. 서버 과부하를 막는다.

### 처리율 제한 장치를 구현하기위한 면접 설계 단계

**1단계. 문제 이해 및 설계 범위 확정**

- 면접관과 소통하며 요구사항을 정리한다.

**2단계. 개략적 설계안 제시 및 동의 구하기**

- 일을 복잡하게 만드는 것을 피하고, 기본적인 클라이언트-서버 통신 모델을 사용하자.
- **처리율 제한 장치를 어디에 둘 것인가?**
    - 클라이언트에 둘 경우, 일반적으로 클라이언트가 처리율 제한을 안정적으로 처리하기에는 무리가 있다. ( = 쉽게 위변조가 가능하다.)
    - 서버에 둘 경우,
    - 미들웨어를 활용
    
    : 클라우드 마이크로 서비스의 경우 처리율 제한 장치는 보통 API 게이트웨이(gateway)라 불리는 컴포넌트에 구현된다.
    
- **처리율 제한 장치 위치 선정시 고려할 수 있는 조건**
    - 현재 사용 중인 기술 스택을 점검해서 사용중인 언어가 서버 측 구현을 지원하기 충분한지?
    - 필요에 맞는 처리율 제한 알고리즘을 찾아라.
    - 설계가 마이크로 서비스에 기반하고 있고, 사용자 인증, ip 허용 목록 관리 등을 처리하기 위해 API 게이트 웨이를 이미 설계에 포함시킨 경우 처리율 제한 기능 또한 게이트웨이에 포함시켜야 할 수도 있다.
    - 처리율 제한 장치를 구현할 인력이 충분한가? 만일 없다면 상용 API 게이트웨이를 사용하는 것이 바람직하다.
- **처리율 제한 알고리즘**
    - **토큰 버킷(tocken bucket)**
        - 아마존, 스트라이프가 API를 통제하기 위해서 사용하는 알고리즘.
        - 토큰 버킷 = 지정된 용량을 갖는 컨테이너
        - 버킷에는 토큰 공급기로 정해진 일정량의 토큰이 주기적으로 채워진다. 토큰이 꽉찬 경우 추가로 공급된 토큰은 버려진다.
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3b128aa8-2b95-401c-9089-9490077bf2a3/ea524c12-d1f4-420f-82b8-859ef6f8ed2d/image.png)
        
        - 토큰이 충분한 경우, 토큰을 하나 꺼낸 뒤, 시스템에 요청을 전달한다.
        - 토큰이 없는 경우, 해당 요청은 버려진다.
        - 동작 과정
            
            ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3b128aa8-2b95-401c-9089-9490077bf2a3/35ad8b8b-0b08-4478-831c-1002e87ad917/image.png)
            
        - 필요한 인자 : 버킷 크기, 토큰 공급률(초당 몇개 토큰 공급할 것인가?)
        - 장점
            - 구현이 쉽다.
            - 메모리 사용 측면에서 효율적
            - 짧은 시간 집중된느 트래픽도 처리 가능
        - 단점
            - 인자 값들을 적절히 튜닝하는 것은 까다로울 것이다.
    - **누출 버킷(leaky bucket)**
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3b128aa8-2b95-401c-9089-9490077bf2a3/24656c42-1bbe-4fdd-9b24-542489f64ca7/image.png)
        
        - FIFO 큐를 이용해서 구현한다.
        - 큐가 가득 찬 경우 해당 요청은 버리며, 주기적으로 큐에서 요청을 꺼내서 처리한다.
        - 쇼피파이에서 이 알고리즘을 사용한다.
        - 필요한 인자 : 버킷 크기, 처리율
        - 장점
            - 큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적이다.
            - 고정된 처리율을 갖고 있기 때문에 안정적인 출력이 필요한 경우 적합하다.
        - 단점
            - 단시간에 많은 트래픽이 몰리는 경우에는 부적합하다. 오래된 요청들이 쌓이며 신규 요청들은 버려짐.
            - 인자 값들을 적절히 튜닝하는 것은 까다로울 것이다.
    - **고정 위도 카운터(fixed window counter)**
        - 타임라인을 고정된 간격으로 나누고 각 윈도(window)마다 카운터를 붙인다.
        - 요청 접수마다 counter는 1씩 증가 시킨다.
        - 사전 설정된 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려진다.
        - 이 알고리즘의 가장 큰 문제 → 윈도의 경계 부근에 순간적으로 많은 트래픽이 몰릴 경우 윈도에 할당된 양보다 더 많은 요청을 처리할 수도 있다.
        - 장점
            - 메모리 효율이 좋다.
            - 이해하기 쉽다.
            - 윈도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기 적합하다.
        - 단점
            - 윈도 경계 부근에서 일시적으로 많은 트래픽이 몰릴 경우, 기대했던 시스템의 처리 한도보다 더 많은 양의 요청을 처리하게 된다.
    - **이동 윈도 로그(sliding window log)**
        - 요청이 들어온 타임 스탬프를 레디스(Redis)의 정렬 집합(sorted set)과 같은 캐시에 보관하며, 새 요청이 오면 만료된 타임스탬프를 삭제한다.
        - 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다.
        - 장점
            - 어느 순간의 윈도를 보더라도 허용되는 개수는 시스템에 허용치를 넘지 않는다.
        - 단점
            - 거부된 요청의 타임스탬프도 저장하고 있기 때문에 다량의 메모리를 사용한다.
    - **이동 윈도 카운터(sliding window counter)**
        
        

**3단계. 상세 설계**

- 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?
- 처리가 제한된 요청들은 어떻게 처리하는가?

- 처리율 제한 규칙
    
    처리율 제한 규칙의 경우 보통 설정 파일(configuration file) 형태로 디스크에 저장된다.
    
- 처리율 한도 초과 트래픽의 처리
    
    처리율 제한 장치가 사용하는 Http 헤더
    
    - X-Ratelimit-Remaining
    - X-Ratelimit-Limit
    - X-Ratelimit-Retry-After
    
    response code : 429(too many requests)
    
    - 처리 방안 2가지
        - 오류 response 후 요청을 버린다.
        - 오류 response 후 요청을 메세지 큐에 보관하여 추후 처리한다.
- 분산 환경에서의 처리율 제한 장치의 구현
    
    고려해야할 점 두 가지 : 경쟁 조건(race condition), 동기화(syncronization)
    
    경쟁 조건 → 루아 스크립트(Lua script), 정렬 집합(sorted set)을 사용하면 해결가능하다.
    
    동기화 → 고정 세션(sticky session), 레디스와 같은 중앙 집중형 데이터 저장소 사용
    
    성능 최적화
    
    지연시간(latency)를 개선하기 위해서 사용자의 트래픽을 가장 가까운 에지 서버(edge server)로 전달한다.
    
    일관성 모델(eventual consistency model)을 사용한다.
    

**3단계. 마무리**

아래 주제에 대해서 이야기를 해보는 것도 좋을 것이다.

- 경성(hard) 또는 연성(soft) 처리율 제한
- 다양한 계층에서의 처리율 제한
- 처리율 제한을 회피하는 방법

---

처리율 제한 관련 라이브러리

[bucket4j](https://bucket4j.com/)

[guava-rate-limiter](https://www.baeldung.com/guava-rate-limiter)

[ratelimitj](https://github.com/mokies/ratelimitj) - 이동 윈도 알고리즘 기반

[resilience4j](https://resilience4j.readme.io/)
